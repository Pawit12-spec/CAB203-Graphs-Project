import unittest, ast, os
import project as P
from inspect import getsource

# WARNING!  Do not edit this file!
# If modify this file then it might not catch errors in your project code.

scriptDirectory = os.path.dirname(__file__)
allowed_modules = [ 'csv', 'graphs', 'digraphs', 'itertools', 'functools' ]

class TestMaxMinDistance(unittest.TestCase):
    def test_1(self):
        r = P.maxMinTransfers('lines1.csv')
        self.assertEqual(r, 1)

    def test_2(self):
        r = P.maxMinTransfers('lines2.csv')
        self.assertEqual(r, 2)

    def test_3(self):
        r = P.maxMinTransfers('lines3.csv')
        self.assertEqual(r, 4)

    def test_4(self):
        r = P.maxMinTransfers('lines4.csv')
        self.assertEqual(r, 6)

    def test_noLoops(self):
        assert_no_loops(self, P.maxMinTransfers)

    
class TestAssignDrivers(unittest.TestCase):

    def test_1(self):
        crew = {
            # Driver,   Roles allowed        ETCS certified, shift,     peekTimeRestricted
            ('Alice',   ('Guard', 'Driver'), True,           'Morning', False),
            ('Bob',     ('Driver'),          False,          'Day',     True),
            ('Charlie', ('Guard'),           True,           'Morning', False),
            ('Denise',  ('Guard', 'Driver'), False,          'Day',     True)
        }

        slots = {
            # Line,  StartTime, EndTime, ETCS required
            ('IPNA', 6, 9, True),
            ('CASP', 11, 13, False)
        }

        assignment = P.assignCrew(crew, slots)

        self.assertEqual(assignment, 
            {
            'IPNA-6-9': ('Alice','Charlie'),
            'CASP-11-13': ('Bob', 'Denise')
        })

    def test_2(self):
        crew = {
            # Driver,   Roles allowed        ETCS certified, shift,     peekTimeRestricted
            ('Alice',   ('Guard', 'Driver'), True,           'Morning', False),
            ('Bob',     ('Driver'),          False,          'Day',     True),
            ('Charlie', ('Guard'),           True,           'Morning', False),
            ('Denise',  ('Guard', 'Driver'), False,          'Day',     True),
            ('Elaine',  ('Guard', 'Driver'), False,          'Night',   False),
            ('Frank',   ('Guard', 'Driver'), True,           'Night',   False),
        }

        slots = {
            # Line,  StartTime, EndTime, ETCS required
            ('IPNA', 6, 9, True),
            ('CASP', 11, 13, False),
            ('RPSP', 17, 19, True)
        }

        assignment = P.assignCrew(crew, slots)

        self.assertEqual(assignment, 
            {
            'IPNA-6-9': ('Alice','Charlie'),
            'CASP-11-13': ('Bob', 'Denise'),
            'RPSP-17-19': ('Frank', 'Elaine')
        })


    def test_3(self):
        crew = {
            # Driver,   Roles allowed        ETCS certified, shift,     peekTimeRestricted
            ('Alice',   ('Guard', 'Driver'), True,           'Morning', False),
            ('Bob',     ('Driver'),          False,          'Day',     True),
            ('Charlie', ('Guard'),           False,          'Morning', False),
            ('Denise',  ('Guard', 'Driver'), False,          'Day',     True),
            ('Elaine',  ('Guard', 'Driver'), False,          'Night',   False),
            ('Frank',   ('Guard', 'Driver'), True,           'Night',   False),
            ('George',  ('Guard', 'Driver'), False,          'Morning',  True),
            ('Helen',   ('Guard', ),         False,          'Morning',  True),
        }

        slots = {
            # Line,  StartTime, EndTime, ETCS required
            ('IPNA', 6, 9, False),
            ('RPSP', 10, 11, True),
            ('CASP', 11, 13, False),
            ('RPSP', 17, 19, True)
        }

        assignment = P.assignCrew(crew, slots)

        self.assertEqual(assignment, None)


    def test_4(self):
        crew = {
            # Driver,   Roles allowed        ETCS certified, shift,     peekTimeRestricted
            ('Alice',   ('Guard', 'Driver'), True,           'Morning', False),
            ('Bob',     ('Driver'),          False,          'Day',     True),
            ('Charlie', ('Guard'),           False,          'Morning', True),
            ('Denise',  ('Guard', 'Driver'), False,          'Day',     True),
            ('Elaine',  ('Guard', 'Driver'), False,          'Night',   False),
            ('Frank',   ('Guard', 'Driver'), True,           'Night',   False),
            ('George',  ('Guard', 'Driver'), False,          'Morning',  False),
            ('Helen',   ('Guard', ),         False,          'Morning',  False),
        }

        slots = {
            # Line,  StartTime, EndTime, ETCS required
            ('IPNA', 6, 9, False),
            ('RPSP', 10, 11, True),
            ('CASP', 11, 13, False),
            ('RPSP', 17, 19, True)
        }

        assignment = P.assignCrew(crew, slots)

        self.assertEqual(assignment, {
            'IPNA-6-9': ('George','Helen'),
            'RPSP-10-11': ('Alice', 'Charlie'),
            'CASP-11-13': ('Bob', 'Denise'),
            'RPSP-17-19': ('Frank', 'Elaine')
        })

    def test_noLoops(self):
        assert_no_loops(self, P.assignCrew)


class TestTrainSchedule(unittest.TestCase):
    def slotsFromSchedule(self, schedule):
        return [ (name, s, s + length)
            for (name, start, end, length, freq) in schedule
            for s in range(start, end + 1, freq )
        ]

    def test_1(self):
        slots = [
            # Line,  StartTime, EndTime
            ('IPNA', 6, 9),
            ('CASP', 11, 13),
            ('ABCD', 9, 12)
        ]

        m = P.trainSchedule(slots)
        self.assertEqual(m, 2)

    def test_2(self):
        slots = [
            # Line,  StartTime, EndTime
            ('IPNA', 6, 9),
            ('IPNA', 7, 10),
            ('IPNA', 8, 11),
            ('CASP', 7, 9),
            ('CASP', 9, 11),
            ('ABCD', 9, 12),
            ('ABCD', 11, 14)
        ]

        m = P.trainSchedule(slots)
        self.assertEqual(m, 6)

    def test_3(self):
        schedule = [         
            # line  start end length frequency    
            ('IPNA', 9,   22, 4,     4),
            ('RPSP', 9,   22, 3,     3),
            ('SHCL', 9,   22, 3,     2),

        ]

        m = P.trainSchedule(self.slotsFromSchedule(schedule))
        self.assertEqual(6, m)

    def test_4(self):
        schedule = [         
            # line  start end length frequency    
            ('IPNA', 6,   22, 4,     4),
            ('RPSP', 6,   22, 3,     3),
            ('SHCL', 6,   22, 2,     5),
        ]

        m = P.trainSchedule(self.slotsFromSchedule(schedule))
        self.assertEqual(5, m)


    def test_noLoops(self):
        assert_no_loops(self, P.trainSchedule)


class TestTrackThroughput(unittest.TestCase):
    def test_1(self):
        trackNetwork = [
            [ 'Ipswitch', 'Darra', 'signal_1', 'Roma Street' ],
            [ 'Springfield', 'Darra' ],
            [ 'Varsity Lakes', 'Bogo Road', 'Merivale Bridge South', 'Merivale Bridge North', 'signal_2', 'Roma Street' ],
            [ 'Cleaveland', 'Bogo Road' ],
            [ 'signal_1', 'signal_2']
        ]

        blockTimes = {
            ('Ipswitch', 'Darra'):  4,
            ('Darra', 'signal_1'):  4,
            ('signal_1', 'Roma Street'): 4,
            ('Springfield', 'Darra'): 4,
            ('Varsity Lakes', 'Bogo Road'):  4,
            ('Bogo Road', 'Merivale Bridge South'):  4,
            ('Merivale Bridge South', 'Merivale Bridge North'): 6,
            ('Merivale Bridge North', 'signal_2'): 3,
            ('signal_2', 'Roma Street'):  3,
            ('Cleaveland', 'Bogo Road'):  4,
            ('signal_1', 'signal_2'): 6 
        }

        capacity = P.trackNetworkCapacity(trackNetwork, blockTimes, 'Roma Street')
        self.assertEqual(capacity, 35)

    def test_2(self):
        trackNetwork = [
            [ 1, 2, 3, 4, 99 ],
            [ 5, 6, 3 ],
            [ 5, 12, 4 ],
            [ 9, 8, 7, 99 ],
            [ 13, 7 ],
            [ 11, 10, 7]
        ]

        blockTimes = {
            (1, 2): 2,
            (2, 3): 2,
            (3, 4): 3,
            (4, 99): 1,
            (5, 6): 2,
            (6, 3): 2,
            (5, 12): 2,
            (12, 4): 5,
            (9, 8): 3,
            (8, 7): 3,
            (7, 99): 1,
            (13, 7): 3,
            (11, 10): 3,
            (10, 7): 3
        }

        capacity = P.trackNetworkCapacity(trackNetwork, blockTimes, 99)
        self.assertEqual(capacity, 92)

    def test_3(self):
        trackNetwork = [
            [ 1, 2, 3, 4, 99 ],
        ]

        blockTimes = {
            (1, 2): 2,
            (2, 3): 2,
            (3, 4): 3,
            (4, 99): 1,
        }

        capacity = P.trackNetworkCapacity(trackNetwork, blockTimes, 99)
        self.assertEqual(capacity, 20)


    def test_4(self):
        trackNetwork = [
            [ 1, 2, 3, 4, 99 ],
            [ 5, 6, 3 ],
            [ 5, 12, 4 ],
            [ 9, 8, 7, 99 ],
            [ 13, 7 ],
            [ 11, 10, 7]
        ]

        blockTimes = {
            (1, 2): 2,
            (2, 3): 2,
            (3, 4): 2,
            (4, 99): 1,
            (5, 6): 2,
            (6, 3): 2,
            (5, 12): 2,
            (12, 4): 4,
            (9, 8): 3,
            (8, 7): 3,
            (7, 99): 2,
            (13, 7): 3,
            (11, 10): 2,
            (10, 7): 1
        }

        capacity = P.trackNetworkCapacity(trackNetwork, blockTimes, 99)
        self.assertEqual(capacity, 75)


    def test_noLoops(self):
        assert_no_loops(self, P.trackNetworkCapacity)


def calls(startNode):
    '''Find function calls in an AST'''
    return {
        node.func.id if isinstance(node.func, ast.Name) else node.func.attr
        for node in ast.walk(startNode)
        if isinstance(node, ast.Call)
    }

def hasLoop(startNode):
    '''Find For and While loops in an AST.'''
    return any( 
        isinstance(node, ast.For) or
        isinstance(node, ast.While)
        for node in ast.walk(startNode)
    )

def functionsWithLoopsR(F=None, functionNodes=None):
    '''Look for functions that have a loop themselves or that depend on a function that has a loop.
    
    This code doesn't understand scopes, so it can't distinguish between functions from different scopes
    that have the same name.  So it can produce a false positive in such cases.
    '''
    
    # base case: functions that have loops in their body
    if F is None:
        syntaxTree = ast.walk(ast.parse(getsource(P)))
        functionNodes = { node for node in syntaxTree if isinstance(node, ast.FunctionDef) }
        F = { node.name for node in functionNodes if hasLoop(node) }

    # Functions that call something in F, but aren't themselves in F yet
    callersOfF = { 
        node.name
        for node in functionNodes
        if node.name not in F and 
        not calls(node).isdisjoint(F)
    }

    if not callersOfF: return F
    
    return functionsWithLoopsR(F | callersOfF, functionNodes)

functionsWithLoops = functionsWithLoopsR()

def assert_no_loops(self, f):
    if f.__name__ in functionsWithLoops:
        self.fail(f'function {f.__name__} uses a loop.')
    
# This test does not count for any marks.  It just helps to ensure
# that your code will run on the test system.
class TestImportedModules(unittest.TestCase):
   def test_modules(self):
      with open('project.py', "r") as f:
         file_raw = f.read()
         player_ast = ast.parse(file_raw)

      def imported_modules():
         for node in ast.walk(player_ast):
               if isinstance(node, ast.Import):
                  yield from (x.name.split('.')[0] for x in node.names)
               if isinstance(node, ast.ImportFrom) and node.level == 0:
                  yield node.module.split('.')[0]

      for module in imported_modules():
         if module not in allowed_modules:
               self.fail(f'module {module} imported by submission but not allowed.')


if __name__ == '__main__':
   unittest.main(argv=['-b'])

